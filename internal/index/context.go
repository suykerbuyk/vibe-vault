package index

import (
	"fmt"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// Projects returns a sorted list of unique project names in the index.
func (idx *Index) Projects() []string {
	seen := make(map[string]bool)
	for _, e := range idx.Entries {
		seen[e.Project] = true
	}
	projects := make([]string, 0, len(seen))
	for p := range seen {
		projects = append(projects, p)
	}
	sort.Strings(projects)
	return projects
}

// ProjectContext generates an Obsidian markdown context document for a project.
func (idx *Index) ProjectContext(project string) string {
	entries := idx.projectEntries(project)
	if len(entries) == 0 {
		return ""
	}

	// Sort chronologically
	sort.Slice(entries, func(i, j int) bool {
		return entries[i].Date < entries[j].Date ||
			(entries[i].Date == entries[j].Date && entries[i].Iteration < entries[j].Iteration)
	})

	var b strings.Builder

	// Frontmatter
	b.WriteString("---\n")
	b.WriteString("type: project-context\n")
	b.WriteString(fmt.Sprintf("project: %s\n", project))
	b.WriteString(fmt.Sprintf("generated: %s\n", time.Now().Format("2006-01-02T15:04:05")))
	b.WriteString(fmt.Sprintf("sessions: %d\n", len(entries)))
	b.WriteString("---\n\n")

	// Title
	b.WriteString(fmt.Sprintf("# %s\n\n", project))

	// Session Timeline
	b.WriteString("## Session Timeline\n\n")
	for _, e := range entries {
		noteName := filenameNoExt(e.NotePath)
		line := fmt.Sprintf("- [[%s]]", noteName)
		if e.Tag != "" {
			line += fmt.Sprintf(" #%s", e.Tag)
		}
		if e.FrictionScore >= 30 {
			line += fmt.Sprintf(" ⚡%d", e.FrictionScore)
		}
		if e.Summary != "" {
			line += fmt.Sprintf(" — %s", e.Summary)
		}
		b.WriteString(line + "\n")
	}
	b.WriteString("\n")

	// Key Decisions — grouped by date, deduped
	decisions := collectDecisions(entries)
	if len(decisions) > 0 {
		b.WriteString("## Key Decisions\n\n")
		var lastDate string
		for _, d := range decisions {
			if d.date != lastDate {
				b.WriteString(fmt.Sprintf("**%s**\n", d.date))
				lastDate = d.date
			}
			b.WriteString(fmt.Sprintf("- %s\n", d.text))
		}
		b.WriteString("\n")
	}

	// Open Threads — from recent 5 sessions, excluding resolved
	threads := collectOpenThreads(entries)
	if len(threads) > 0 {
		b.WriteString("## Open Threads\n\n")
		for _, t := range threads {
			b.WriteString(fmt.Sprintf("- [ ] %s\n", t))
		}
		b.WriteString("\n")
	}

	// Friction Patterns — recurring high-friction signals
	frictionPatterns := collectFrictionPatterns(entries)
	if len(frictionPatterns) > 0 {
		b.WriteString("## Friction Patterns\n\n")
		for _, fp := range frictionPatterns {
			b.WriteString(fmt.Sprintf("- %s\n", fp))
		}
		b.WriteString("\n")
	}

	// Key Files — files appearing in >= 3 sessions
	keyFiles := collectKeyFiles(entries)
	if len(keyFiles) > 0 {
		b.WriteString("## Key Files\n\n")
		for _, kf := range keyFiles {
			b.WriteString(fmt.Sprintf("- `%s` (%d sessions)\n", kf.path, kf.count))
		}
		b.WriteString("\n")
	}

	b.WriteString("---\n")
	b.WriteString("*Auto-generated by vv index*\n")

	return b.String()
}

func (idx *Index) projectEntries(project string) []SessionEntry {
	var entries []SessionEntry
	for _, e := range idx.Entries {
		if e.Project == project {
			entries = append(entries, e)
		}
	}
	return entries
}

type datedDecision struct {
	date string
	text string
}

func collectDecisions(entries []SessionEntry) []datedDecision {
	seen := make(map[string]bool)
	var decisions []datedDecision

	for _, e := range entries {
		for _, d := range e.Decisions {
			if !seen[d] {
				seen[d] = true
				decisions = append(decisions, datedDecision{date: e.Date, text: d})
			}
		}
	}
	return decisions
}

func collectOpenThreads(entries []SessionEntry) []string {
	// Collect all decisions for resolution checking
	var allDecisions []string
	for _, e := range entries {
		allDecisions = append(allDecisions, e.Decisions...)
	}

	// Take threads from last 5 sessions (entries already sorted chronologically)
	start := len(entries) - 5
	if start < 0 {
		start = 0
	}
	recent := entries[start:]

	seen := make(map[string]bool)
	var threads []string

	for _, e := range recent {
		for _, t := range e.OpenThreads {
			if seen[t] {
				continue
			}
			seen[t] = true

			// Check if resolved by any decision
			if isResolvedByDecisions(t, allDecisions) {
				continue
			}
			threads = append(threads, t)
		}
	}
	return threads
}

// isResolvedByDecisions checks if a thread has significant word overlap with any decision.
func isResolvedByDecisions(thread string, decisions []string) bool {
	threadWords := significantWords(thread)
	if len(threadWords) == 0 {
		return false
	}
	for _, d := range decisions {
		decisionWords := significantWords(d)
		overlap := len(setIntersection(threadWords, decisionWords))
		if overlap >= 2 {
			return true
		}
	}
	return false
}

type keyFile struct {
	path  string
	count int
}

func collectKeyFiles(entries []SessionEntry) []keyFile {
	counts := make(map[string]int)
	for _, e := range entries {
		for _, f := range e.FilesChanged {
			counts[f]++
		}
	}

	var files []keyFile
	for path, count := range counts {
		if count >= 3 {
			files = append(files, keyFile{path: path, count: count})
		}
	}

	// Sort by count descending
	sort.Slice(files, func(i, j int) bool {
		if files[i].count != files[j].count {
			return files[i].count > files[j].count
		}
		return files[i].path < files[j].path
	})

	return files
}

func collectFrictionPatterns(entries []SessionEntry) []string {
	var highFriction int
	var totalCorrections int
	var totalScore int
	scored := 0

	for _, e := range entries {
		if e.FrictionScore > 0 {
			scored++
			totalScore += e.FrictionScore
			totalCorrections += e.Corrections
			if e.FrictionScore >= 40 {
				highFriction++
			}
		}
	}

	if scored == 0 {
		return nil
	}

	var patterns []string

	if highFriction > 0 {
		patterns = append(patterns, fmt.Sprintf("%d of %d sessions had high friction (score ≥ 40)", highFriction, len(entries)))
	}

	if totalCorrections > 0 {
		patterns = append(patterns, fmt.Sprintf("%d total corrections across %d sessions", totalCorrections, scored))
	}

	avgScore := float64(totalScore) / float64(scored)
	if avgScore > 15 {
		patterns = append(patterns, fmt.Sprintf("Average friction score: %.0f/100", avgScore))
	}

	return patterns
}

func filenameNoExt(path string) string {
	base := filepath.Base(path)
	ext := filepath.Ext(base)
	if ext != "" {
		return base[:len(base)-len(ext)]
	}
	return base
}
